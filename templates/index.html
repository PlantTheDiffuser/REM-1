<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Reverse Engineering Model Test</title>
  <style>
    .feature-box {
      border: 2px solid #333;
      border-radius: 24px; /* Match viewer's radius */
      padding: 5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 20px;
      max-width: 900px;
      background: #fafafa;
    }

    .feature-number {
      font-size: 2em;
      font-weight: bold;
      width: 32px;
      padding-left: 30px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }

    .feature-text {
      font-size: 2em; /* 6 times bigger */
      font-weight: bold;
      padding: 0 24px;
      padding-right: 50px;
      white-space: nowrap;
      max-width: 220px;
      overflow: hidden;
      text-overflow: clip;
    }

    .viewer {
      width: 400px;
      height: 400px;
      border-radius: 24px; /* Match feature-box radius */
      overflow: hidden;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      margin-left: auto; /* Push viewer to the right */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      max-width: 900px;
      margin: 0 auto;
    }

    .title {
      font-weight: bold;
      font-size: 3em;
      margin-bottom: 16px;
      margin-top: 8px;
      letter-spacing: 1px;
      text-align: center;
      flex: 1;
    }

    .reset-button {
      margin-left: 16px;
    }

    .reset-button button {
      font-size: 1.2em;
      padding: 8px 24px;
      border-radius: 8px;
    }
    .reset-camera-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      border: 1px solid #ccc;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .reset-camera-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    /* Processing overlay styles */
    #processing-overlay {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .processing-box {
      background: #fff;
      padding: 20px 24px;
      border-radius: 8px;
      width: 400px;
      text-align: center;
    }
    .progress-wrap {
      background: #eee;
      height: 12px;
      border-radius: 6px;
      overflow: hidden;
      margin-top: 12px;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #5b9cff, #2b6cff);
      width: 0%;
      transition: width 250ms linear;
    }
    .progress-text { margin-top: 8px; font-size: 14px; }
  </style>
</head>
<body>
  <h1>CAD Reverse Engineering Made Easy</h1>
  <p>Upload an STL File</p>

  {% if message %}
    <p style="color:green;">{{ message }}</p>
  {% endif %}
  <form action="/" method="POST" enctype="multipart/form-data">
    <input type="file" name="file">
    <input type="submit" value="Run">
  </form>

  <!-- Processing overlay + progress bar -->
  <div id="processing-overlay" style="display:none;">
    <div class="processing-box">
      <div class="processing-message">Processing, please wait...</div>
      <div class="progress-wrap">
        <div id="progress-bar" class="progress-bar" style="width:0%"></div>
      </div>
      <div id="progress-text" class="progress-text">0%</div>
    </div>
  </div>


  {% if error %}
    <p style="color:red;">{{ error }}</p>
  {% endif %}

  {% if result %}
    <h2>{{ result }}</h2>
  {% endif %}

  {% if features %}
    <div class="title-container">
      <div class="title">
        {{ features[0] | basename_noext }}
      </div>
      <form method="POST" action="/" class="reset-button">
        <input type="hidden" name="reset" value="1">
        <button type="submit">Reset</button>
      </form>
    </div>

    <h3>Predicted Features:</h3>
    {% for f in features %}
      {% if loop.index0 == 0 %}
        <!-- Skip the first feature as it's already displayed in the title -->
      {% else %}
        <div class="feature-box">
          <div class="feature-number">{{ loop.index0 }})</div>
          <div class="feature-text">{{ f }}</div>
              <div class="viewer" id="viewer-{{ loop.index0 }}" data-stl="{{ url_for('static', filename='working-' ~ loop.index0 ~ '.stl') }}">
                <button class="reset-camera-btn" id="reset-{{ loop.index0 }}" title="Reset camera">Reset</button>
              </div>
        </div>
      {% endif %}
    {% endfor %}
  {% endif %}

  <!-- Include Three.js, STLLoader and OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Form submission hijack to show processing overlay and progress
    (function() {
      const form = document.querySelector('form[action="/"]');
      if (!form) return;

      form.addEventListener('submit', function (e) {
        // Allow reset posts to proceed normally
        if (form.querySelector('input[name="reset"]')) return;
        e.preventDefault();

        const overlay = document.getElementById('processing-overlay');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        overlay.style.display = '';
        progressBar.style.width = '0%';
        progressText.textContent = '0%';

        const xhr = new XMLHttpRequest();
        xhr.open('POST', form.action);

        xhr.upload.addEventListener('progress', function (ev) {
          if (ev.lengthComputable) {
            const percent = Math.round(ev.loaded / ev.total * 100);
            progressBar.style.width = percent + '%';
            progressText.textContent = percent + '% (upload)';
          }
        });

        // While server processes (after upload completes) we don't get progress events.
        // Show an indeterminate progress animation by pulsing the bar.
        let pulsing = false;
        function startPulse() {
          pulsing = true;
          progressBar.style.transition = 'none';
          progressBar.style.width = '30%';
          setTimeout(() => {
            if (!pulsing) return;
            progressBar.style.transition = 'width 800ms ease-in-out';
            progressBar.style.width = '70%';
          }, 50);
        }
        function stopPulse() {
          pulsing = false;
          progressBar.style.transition = 'width 250ms linear';
        }

        xhr.addEventListener('load', function () {
          // Replace the page with server response (assumes HTML response)
          stopPulse();
          document.open();
          document.write(xhr.responseText);
          document.close();
        });

        xhr.addEventListener('error', function () {
          stopPulse();
          alert('Upload failed.');
          overlay.style.display = 'none';
        });

        xhr.onreadystatechange = function() {
          if (xhr.readyState === 2) {
            // headers received: now start pulsing for server processing
            startPulse();
            progressText.textContent = 'Processing...';
          }
        };

        const formData = new FormData(form);
        xhr.send(formData);
      });
    })();

    function loadSTL(containerId) {
      const container = document.getElementById(containerId);
      const stlUrl = container.getAttribute('data-stl');

      // Create renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      container.appendChild(renderer.domElement);

      // Scene and camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 10000);

      // Controls for interaction (rotate, zoom, pan)
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.screenSpacePanning = false;
      controls.minDistance = 10;
      controls.maxDistance = 2000;

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.6);
      directional.position.set(1, 1, 1).normalize();
      scene.add(directional);

      // Fallback text node for errors
      const errorNode = document.createElement('div');
      errorNode.style.position = 'absolute';
      errorNode.style.color = '#c00';
      errorNode.style.fontSize = '12px';
      errorNode.style.display = 'none';
      errorNode.textContent = 'Failed to load STL';
      container.style.position = 'relative';
      container.appendChild(errorNode);

      const loader = new THREE.STLLoader();
      // We'll store initial camera state here so reset can restore it
      let initialState = null;
      loader.load(
        stlUrl,
        function (geometry) {
          if (!geometry) {
            errorNode.style.display = '';
            return;
          }

          geometry.computeBoundingBox();
          const boundingBox = geometry.boundingBox;
          const center = new THREE.Vector3();
          boundingBox.getCenter(center);
          geometry.translate(-center.x, -center.y, -center.z);

          const size = new THREE.Vector3();
          boundingBox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z) || 1;
          const scale = Math.min(container.clientWidth, container.clientHeight) * 0.6 / maxDim;
          geometry.scale(scale, scale, scale);

          const material = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.2, roughness: 0.6 });
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          // Compute bounding sphere and fit camera so the object is fully visible (zoomed out)
          geometry.computeBoundingSphere();
          const sphere = geometry.boundingSphere;
          const radius = sphere ? sphere.radius : Math.max(size.x, size.y, size.z) * 0.5;
          const centerSphere = sphere ? sphere.center : new THREE.Vector3(0, 0, 0);

          // Set control target to model center
          controls.target.copy(centerSphere);

          // Determine the distance required to fit the sphere within camera fov
          const fov = camera.fov * (Math.PI / 180); // convert to radians
          // Distance from sphere center to camera to fully fit the sphere
          let distance = Math.abs(radius / Math.sin(fov / 2));
          if (!isFinite(distance) || distance === 0) {
            distance = Math.max(size.x, size.y, size.z) * 2.5;
          }
          // Add small margin
          distance *= 1.15;

          // Position camera along a normalized diagonal so it's not axis-aligned
          const diag = new THREE.Vector3(1, 1, 1).normalize();
          camera.position.copy(diag.multiplyScalar(distance).add(centerSphere));
          camera.lookAt(centerSphere);

          // Configure controls limits so user can zoom in/out but initial view is fully zoomed out
          controls.maxDistance = distance * 10;
          controls.minDistance = Math.max(1, radius * 0.1);
          controls.update();

          // Save initial state for reset button
          initialState = {
            position: camera.position.clone(),
            target: controls.target.clone(),
            maxDistance: controls.maxDistance,
            minDistance: controls.minDistance
          };

          // Wire reset button if present
          const resetBtn = container.querySelector('.reset-camera-btn');
          if (resetBtn) {
            resetBtn.disabled = false;
            resetBtn.addEventListener('click', () => {
              if (!initialState) return;
              const duration = 1000; // milliseconds
              const startTime = performance.now();

              const startPos = camera.position.clone();
              const startQuat = camera.quaternion.clone();
              const endPos = initialState.position.clone();

              // compute end quaternion so camera looks at the target
              const tmpCam = new THREE.PerspectiveCamera();
              tmpCam.position.copy(endPos);
              tmpCam.lookAt(initialState.target);
              const endQuat = tmpCam.quaternion.clone();

              const startTarget = controls.target.clone();
              const endTarget = initialState.target.clone();

              // disable controls during animation
              controls.enabled = false;

              function animateReset(now) {
                const t = Math.min(1, (now - startTime) / duration);
                // easeInOut
                const ease = 0.5 - 0.5 * Math.cos(Math.PI * t);

                // interpolate position
                camera.position.lerpVectors(startPos, endPos, ease);
                // slerp quaternion
                THREE.Quaternion.slerp(startQuat, endQuat, camera.quaternion, ease);
                // interpolate controls target
                controls.target.lerpVectors(startTarget, endTarget, ease);

                controls.update();

                if (t < 1) {
                  requestAnimationFrame(animateReset);
                } else {
                  // final state
                  camera.position.copy(endPos);
                  camera.quaternion.copy(endQuat);
                  controls.target.copy(endTarget);
                  controls.maxDistance = initialState.maxDistance;
                  controls.minDistance = initialState.minDistance;
                  controls.update();
                  controls.enabled = true;
                }
              }

              requestAnimationFrame(animateReset);
            });
          }

          // Render loop
          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }
          animate();
        },
        undefined,
        function (err) {
          console.error('STL load error:', err);
          errorNode.style.display = '';
        }
      );

      // Resize handling
      const resizeObserver = new ResizeObserver(() => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
      resizeObserver.observe(container);
    }

    // Load all viewers
    document.querySelectorAll('.viewer').forEach(viewer => {
      loadSTL(viewer.id);
    });
  </script>
</body>
</html>
